# 通用的I/O模型

## [0x00]概述

所有执行I/O操作的系统调用都以文件描述符，一个非负整数(通常是小整数)，来指代打开的文件。文件描述符用以表示所有类型已打开文件，包括管道(pipe)、FIFO、socket、终端、设备和普通文件。针对每个进程，文件描述符都自成一套。

按照惯例，大多数程序都希望能够使用3种标准的文件描述符，如表1所示。在程序开始运行之前，shell代表程序打开这3个文件描述符。更确切的说，程序继承了shell文件描述符的副本，这3个描述符始终是打开的。如果命令行指定输入/输出进行重定向操作，那么shell会对文件描述符做适当修改，然后再启动程序。

| 文件描述符 |   用途   |   POSIX名称   | stdio流 |
| :--------: | :------: | :-----------: | :-----: |
|     0      | 标准输入 | STDIN_FILENO  |  stdin  |
|     1      | 标准输出 | STDOUT_FILENO | stdout  |
|     2      | 标准错误 | STDERR_FILENO | stderr  |

在程序指代这些描述符时，可以使用数字(0、1、2)表示，或者采用<unistd.h>所定义的POSIX标准名称。

虽然stdin、stdout和stderr变量在程序初始化时对用于指代进程的标准输入、标准输出和标准错误，但是调用freopen()库函数可以使这些变量指代其他任何文件对象。作为其操作的一部分，freopen()可以在将流(stream)重新打开之际一并更换隐匿其中的文件描述符。换言之，针对stdout调用freopen()函数后，无法保证stdout变量仍然为1。

## [0x01]通用I/O

UNIX I/O模型的显著特点之一是其输入输出的通用性概念。这意味着使用4个同样的系统调用open()、read()、write()和close()可以对所有类型的文件执行I/O操作，包括终端之类的设备。因此，仅使用这些系统调用编写程序，将对任何类型的文件有效。

要实现通用I/O，就必须确保每一个文件系统和设备驱动程序都实现了相同的I/O系统调用集。由于文件系统或设备锁特有的操作细节在内核中处理，在编程时通常可以忽略设备专有的因素。一旦应用程序要访问文件系统或设备的专有功能时，可以选择ioctl系统调用，这个调用为通用I/O模型之外的专有特性提供了访问接口。

## [0x02]打开一个文件：open()

open()调用既能打开一个已经存在的文件，也能创建并打开一个新文件。

```c
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags, .../* mode_t mode */);
		returns file descriptor on success, or -1 on error.
```

要打开的文件由参数pathname来标识。如果pathname是一个符号链接，会对其进行街引用。如果调用成功，open()将返回一个文件描述符，用于在后续函数调用中指代该文件。如果发生错误，则返回-1，并将errno设置为相应的错误标志。

参数flags是位掩码，用于指定文件的访问模式，可选择下表所示的常量之一。(早期的UNIX实现中使用数字0、1、2，而不是下表中列的常量名称。大多数现代UNIX实现将这些常量定义为上述相应数字。由此可见，O_RDWR并不等同于O_RDONLY | O_WRONLY，后者组合属于逻辑错误。

| 访问模式 |       描述       |
| :------: | :--------------: |
| O_RDONLY | 以只读的方式打开 |
| O_WRONLY | 以只写的方式打开 |
|  O_RDWR  | 以读写的方式打开 |

当调用open()创建新文件时，位掩码参数mode指定了文件的访问权限。(SUSv3规定，mode的数据类型mode_t属于整数类型)如果open()并未指定O_CREAT标志，则可以省略mode参数。

### open()调用锁返回的文件描述符数值

SUSv3规定，如果调用open()成功，必须保证他的返回值为进程未使用文件描述符中数值最小者。可以利用这个特点以特定文件描述符打开一个文件。例如，如下代码序列就会