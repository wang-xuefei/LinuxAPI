# 进程

## [0x00]进程和程序

进程(process)是一个可执行程序(program)的实例。本节将阐述进程定义，并澄清其与程序之间的区别。

程序是包含了一系列信息的文件，这些信息描述了如何在运行是创建一个进程，锁包括的内容如下所示。

-  二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息(metainformation)。内核(kernel)利用此信息来解释文件中的其他信息。历史上，UNIX可执行文件曾有两种广泛使用的格式，分别为最初的a.out（汇编程序输出）和更加复杂的COFF(通用对象文件格式)。现在，大多数UNIX实现(包括Linux)采用可执行连接格式(ELF)，这一文件格式比老版本格式具有更多优点。
- 机器语言指令：对程序算法进行编码。
- 程序入口地址：标识程序开始执行时的其实指令位置。
- 数据：程序文件包含的变量初始值和程序使用的字面常量(literal constant)值(比如字符串)。
- 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包括调试和运行时的符号解析(动态链接)。
- 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名
- 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。

可以用一个程序来创建许多进程，或者反过来说，许多进程运行的可以是同一程序。

在此将本节开始时给出的进程定义重新改写为，进程是有内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。

从内核角度看，进程由用户内存空间(user-space memory)和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的符号(IDs)、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。

## [0x01]进程号和父进程号

每个进程都有一个进程号(PID)，进程号是一个正数，用以唯一标识系统中的某个进程。对各种系统调用而言，进程号有时可以作为传入参数，有事可以作为返回值。比如，系统调用kill()允许调用者向拥有特定进程而言唯一的标识符时，进程号就会派上用场。常见的例子是将进程号作为与进程相关文件名的一部分。

系统调用getpid()返回调用进程的进程号。

```c
#include <unistd.h>

pid_t getpid(void);
								Always successfully returns process ID of caller.
```

getpid()返回值的数据类型为pid_t，该类型是有SUSv3所规定的整数类型，专用于储存进程号。

除了少数系统进程外，比如init进程(进程号为1)，程序与运行该程序进程的进程号之间没有固定关系。

Linux内核限制进程号需要小于等于32767。新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用。每当进程号大奥32767的限制时，内核将重置进程号计数器，以便从小整数开始分配。

一旦金超达到32767，会将进程号计数器重置为300，而不是1。之所以如此，是因为低数值的进程号为系统进程和守护进程所长期占用，在此范围内搜索尚未使用的进程号只会是浪费时间。

在Linux2.4版本及更早版本中，进程号的上限32767，由内核常量PID_MAX所定义。在Linux 2.6版本中，情况有所改变。尽管进程的默认上限仍是32767，但可以通过Linux系统特有的/proc/sys/kernel/pid_max文件来进行调整(其值=最大进程号-1)。在32位平台中，pid_max文件的最大值为32768，但在64位平台中，该文件的最大值可以高达到400万，系统可能容纳的进程数量会非常庞大。

每个进程都有一个创建自己的父进程。使用系统调用getppid()可以检索到父进程号。

```c
#include <unistd.h>

pid_t getppid(void);
			Always successfully returns process ID of parent of caller
```

实际上，每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父进程又有自己的父进程，以此类推，回溯到1号进程——init进程，即所有进程的始祖。使用pstree(1)命令可以查看到这一“家族树”（family tree）。

如果子进程的父进程终止，则子进程就会变成“孤儿”，init进程随即将收养该进程，子进程后续对getppid()的调用将返回进程号1。

通过查看由Linux系统所特有的/proc/PID/status文件所提供的PPid字段，可以获知每个进程的父进程。

## [0x02]进程内存布局

每个进程所分配的内存由很多部分组成，通常称为"段(segment)"。

- 文本段包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。

- 初始化数据段包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。

- 未初始化数据段包含了未进行显式初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。出于历史原因，此段常被称为BSS段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。

- 栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。6.5节将深入讨论栈帧。
- 堆（heap）是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作program break。

对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。

size(1)命令可显示二进制可执行文件的文本段、初始化数据段、非初始化数据段（bss）的段大小。

正文中使用的术语“段（segment）”不应与一些硬件体系架构，比如x86-32中使用的硬件分段（segmentation）相混淆。相反，本文中的段是对UNIX系统中进程虚拟内存的逻辑划分。有时，会使用术语“区（section）”来替代段，因为在当下风行的可执行文件格式（ELF）规范中，采用的术语与“区”更趋一致。

本书会在多处涉及这种情况：库函数返回的指针指向静态分配的内存。这意味着，该内存既可在初始化数据段中分配，也可在非初始化数据段中分配。（某些情况下，库函数转而会在堆上对内存做一次性动态分配，然而，这一实现细节与这里所要表达的意思无关。）库函数有时会通过静态分配的内存来返回信息，了解这一情况至关重要，因为这片内存的存在独立于函数调用，后续对同一函数的调用可能会将其覆盖（有时，后续对相关函数的调用也有相同的效应）。使用静态分配的内存会使函数不可重入（nonreentrant）。21.1.2节和31.1节将深入讨论重入（reentrancy）问题。

程序清单6-1展示了不同类型的C语言变量，并以注释说明每种变量分属于哪个段。这些说明正确的前提是假定使用了非优化的编译器，且在应用程序二进制接口（ABI）中，是通过栈来传递所有参数的。实际上，优化编译器会将频繁使用的变量分配于寄存器中，或者索性将变量彻底剔除 。此外，一些ABI需要通过寄存器，而不是栈，来传递函数实参和结果。尽管如此，本例只是意在展示C语言变量和进程各段间的映射关系。

